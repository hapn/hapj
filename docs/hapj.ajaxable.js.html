<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>JSDoc: Source: ui/hapj.ajaxable.js</title>

<script src="scripts/prettify/prettify.js"> </script>
<script src="scripts/prettify/lang-css.js"> </script>
<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
<link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

<h1 class="page-title">Source: ui/hapj.ajaxable.js</h1>




    
    <section>
        <article>
            <pre class="prettyprint source"><code>/** 
 * Copyright (c) 2012, Jiehun.com.cn Inc. All Rights Reserved
 * @author dengxiaolong@jiehun.com.cn
 * @date 2012-02-16
 * @version 1.0 
 * @description 用来实现各种元素的异步化请求
 **/
!function($, H){
	"use strict";
	
var _d = decodeURIComponent;
function getKeyValue(from, kvTag, key) {
	var arr = from.split('&'), i, l, ret = {};
	for(i = 0, l = arr.length; i &lt; l; i++ ) {
		var tmp = arr[i].split(kvTag), k = _d($.trim(tmp[0]));
		if (!k) continue;
		if (k in ret) {
			if (!$.isArray(ret[k])) {
				ret[k] = [ret[k]];
			}
			ret[k].push(_d(tmp[1]));
		} else {
			ret[k] = _d(tmp[1]);
		}
	}
	if (key) {
		return key in ret ? ret[key] : null;
	}
	return ret;
}
var submitHandler = function(form, options) {
	if (typeof options.beforeSubmit == 'function') {
		options.beforeSubmit.call(form);
	}
	
	if (options.confirm) {
		switch(typeof options.confirm) {
			case 'string':
				if (window.confirm(options.confirm) === false) {
					return false;
				}
				break;
			case 'function':
				var ret = options.confirm.call(form);
				if (ret === false) {
					return false;
				}else if(typeof ret == 'string'){
					if (window.confirm(ret) === false) {
						return false;
					}
				}
				break;
			default:
				break;
		}
	}
	var action = options.action || form.action || document.URL,
	data = $(form).param();
	
	if (options.pack) {
		options.pack.call(null, data);
	}
	
    $.ajax({
        type: form.method ? form.method : 'POST',
        url: action,
        dataType: 'json',
        data: data,
        success: function(data){
			if (typeof options.afterSubmit == 'function') {
				options.afterSubmit.call(form);
			}
            successHandler.call(form, data, options);
        }
    });
},
successHandler = function(data, options) {
	if (!data.err || data.err.indexOf('.ok') >= 0) {
        options.ok && options.ok.call(this, data.data);
    } else {
    	options.error && options.error.call(this, data.err);
    }
},
/**
 * 发一个ajax请求
 * @param {Object} elem
 * @param {Object} options
 */
ajaxPost = function(elem, options) {
	var href = options.href || elem.href;
	var func = function(){
		if (typeof href == 'function') {
			href = href.call(elem);
		}
		$.ajax({
			url: href,
			type: 'POST',
			dataType: 'json',
			success: function(data){
				successHandler.call(elem, data, options);
			}
		});
	};
	
	var cfStr = options.confirm ? options.confirm : (elem.getAttribute('confirm') ? elem.getAttribute('confirm') : '');
	if (typeof cfStr == 'function') {
		if(cfStr.call(elem) === false){
			return false;
		}
		cfStr = cfStr.call(elem);
	}
	if (cfStr) {
		if (window.confirm(cfStr)) {
			func(elem, options);
		}
	} else {
		func(elem, options);
	}
};

/**
 * @namespace jQuery.ajaxable
 * @description 实现元素的异步化请求
 */
$.ajaxable = /** @lends jQuery.ajaxable*/{
		/**
		 * 表单的异步请求也非常多，在我们的体系下，所有的请求都是基于ajax请求发出的。这里我们有一些假设的前提：
		&lt;ol>
		&lt;li>数据都是以json格式返回来。&lt;/li>
		&lt;li>数据返回的是一个对象。有err和data两个键。&lt;/li>
		&lt;li>如果err为空或者err中包含ok字符串，认为这个表单提交动作是成功的，否则为失败。&lt;/li>
		&lt;/ol>
		 * @param {HtmlElement} table
		 * @param {Object} options 默认可以不传入任何值。具有如下参数：
		 * &lt;h4>函数&lt;/h4>
		 * &lt;dl>
		 *  &lt;dt>pack:&lt;em>function(options)&lt;/em>&lt;/dt>
		 *  &lt;dd>提交数据前对表单的数据进行整理和封装。默认已经对type=password的表单项进行了md5加密，没有特殊要求都可以不适用此函数。&lt;/dd>
		 *  &lt;dt>ok:&lt;em>function(data)&lt;/em>&lt;/dt>
		 *  &lt;dd>表单提交成功时调用的函数。&lt;/dd>
		 *  &lt;dt>error:&lt;em>function(code, desc)&lt;/em>&lt;/dt>
		 *  &lt;dd>表单提交失败是调用的函数。&lt;/dd>
		 *  &lt;dt>confirm:&lt;em>string | function&lt;/em>&lt;/dt>
		 *  &lt;dd>确认字符串。如果是字符串，会弹出提示框让用户确认，用户确认后才会继续后面的操作。如果是函数，返回为false时，就不会继续后面的操作。&lt;/dd>
		 *  &lt;dt>beforeSubmit:&lt;em>Function&lt;/em>&lt;/dt>
		 *  &lt;dd>在提交之前进行的处理&lt;/dd>
		 * &lt;/dl>
		 * @example 
&lt;form method="post" action="/static/test/cities.html" id="formAdd"&gt;
	&lt;input type="hidden" name="username" value="hello"/&gt;
	&lt;input type="password" name="pwd" value="pass"/&gt;
	&lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
&lt;script&gt;
$('#formAdd').ajaxable({
	ok:function() {
		
	}
});
&lt;/script&gt;
		 */
	ajaxForm: function(form, options) {
		options = options || {};
		if (!options._submited_) {
			$(form).submit(('beforeSubmit' in options) ? function(e){
				options._submited_ = true; // 已经被提交了
				return options.beforeSubmit.call(form, e, options);
			} : function() {
				options._submited_ = true;
				submitHandler(form, options); // 已经被提交了
				return false;
			});
		} else {
			submitHandler(form, options);
		}
	},
	/**
	 * 实现图片的异步化加载
	 * @param {HtmlElement} img
	 * @param {Object} options 选项
	 * &lt;dl>
	 *  &lt;dt>cache&lt;/dt>
	 *  &lt;dd>是否缓存，默认为false&lt;/dd>
	 *  &lt;dt>timeKey&lt;/dt>
	 *  &lt;dd>用来表示时间的key，默认为t&lt;/dd>
	 * &lt;/dl>
	 * @example 这部分最典型的应用场景就是解决图片验证码的更新问题。
&lt;img id="vCode" src="/util/vcode.jpg"/&gt;&lt;a href="" id="refreshVCode"&gt;Refresh&lt;a&gt;
&lt;script&gt;
var vCode = $('#vCode');
$('#refreshVCode').click(function() {
	vCode.ajaxable();
	// or jQuery.ajaxable.ajaxImg($('#vCode'));
});
&lt;/script&gt;
	 */
	ajaxImg: function(img, options) {
		var o = {
			cache:false,
			timeKey:'t'
		};
		$.extend(o, options);
		var src = img.src;
		
		if (!o.cache) {
			var pos = src.indexOf('?'), 
				params = pos >= 0 ? getKeyValue(src.substr(pos + 1)) : {};
			if (o.timeKey in params) {
				$.each(params, function(i){
					if (i == o.timeKey) {
						params[i] = new Date().getTime();
					}
				});
				src = (pos > 0 ? src.substr(0, pos) + '?' : src) + $.params(params);
			} else {
				src = src + (pos > 0 ? '&' : '?') + o.timeKey + '=' + new Date().getTime();
			}
			img.src = src;
		} else {
			img.src = '';
			img.src = src;
		}
	},
	/**
	 * ajax化一个select控件
	 * @param {HtmlElement} select
	 * @param {Object} options 默认可以不传入任何值。具有如下参数：
	 * &lt;dl>
	 *  &lt;dt>url&lt;/dt>
	 *  &lt;dd>切换下拉框选项后，需要访问的url。可以传入一个变量{value}，异步请求时会将其替换为下拉框当前选中的值。另外，也可以直接给下拉框顶一个属性ajax-url来定义异步请求的url。&lt;/dd>
	 *  &lt;dt>dataType&lt;/dt>
	 *  &lt;dd>返回数据的格式，默认为json&lt;/dd>
	 *  &lt;dt>target&lt;/dt>
	 *  &lt;dd>返回数据后用来处理数据的对象，默认会使用当前对象的下一个DOM节点。&lt;/dd>
	 *  &lt;dt>pack&lt;/dt>
	 *  &lt;dd>对返回数据进行处理的函数。&lt;/dd>
	 *  &lt;dt>success&lt;/dt>
	 *  &lt;dd>将返回数据进行处理的函数。默认已经有一个处理函数，其逻辑如下：&lt;br/>
如果返回数据被处理成[{name:’name1’, value:’value1’]}的形式，并且dataType为json格式，target也是一个下拉框，那么会将数据自动加载到target作为选项；如果dataType为html，会自动将target的innerHTML设置为返回的数据。&lt;/dd>
	 *  &lt;dt>ok:&lt;em>function(data)&lt;/em>&lt;/dt>
	 *  &lt;dd>表单提交成功时调用的函数。&lt;/dd>
	 *  &lt;dt>error:&lt;em>function(code, desc)&lt;/em>&lt;/dt>
	 *  &lt;dd>表单提交失败是调用的函数。&lt;/dd>
	 * &lt;/dl>
	 * @example
&lt;select id="selCity" ajax-url="/static/test/cities.html?pid={value}"&gt;
	&lt;option value="110000"&gt;北京市&lt;/option&gt;
	&lt;option value="210000"&gt;上海市&lt;/option&gt;
&lt;/select&gt;&lt;select name="city_id"&gt;&lt;/select&gt;
&lt;script&gt;
	$('#cities').ajaxable({
		pack: function(data) {
			var ret = [];
			$.each(data.cities, function(id) {
				ret.push({name:data.cities[id], value:id});
			};
			return ret;
		}
	});
&lt;/script&gt;

	 */
	ajaxSelect: function(select, options) {
		var o = {
			url:select.getAttribute('ajax-url'), 
			dataType:'json',
			pack: null,
			type: 'get',
			success: function(ret){
				if (o.dataType == 'json' && o.target && o.target.nodeName == 'SELECT') {
					var target = o.target;
					if (ret.data) {
						var data = ret.data;
						if (typeof o.pack == 'function') {
							data = o.pack(data);
						}
						target.options.length = 0;
						H.each(data, function(k, v){
							if(!!this.selected){
								target.options[target.options.length] = new Option(v.name, v.value, v.selected);
							}else{
								target.options[target.options.length] = new Option(v.name, v.value);
							}
						})
					}
				} else {
					if (o.dataType == 'html' && o.target) {
						$(o.target).html(ret);
					}
				}
				successHandler.call(select, ret, options);
			}
		};
		$.extend(o, options);
		if (!o.target) {
			o.target = $(select).next('select')[0];
		}
		var fn = function(){
			$.ajax({
				url: o.url.replace('{value}', select.value),
				type: o.type,
				dataType: o.dataType,
				success: o.success
			});
		};
		$(select).on('change', fn);
		if (select.value && select.value > 0) {
			fn();
		}
	},
	/**
	 * ajax化一个面板
	 * @param {HtmlElement} pnl
	 * @param {Object} options
	 */
	ajaxPanel: function(pnl, options) {
		var o = {area:'div.pager', dataType:'html', succss: function(html){
			$(pnl).html(html);
		}};
		$.extend(o, options);
		$(pnl).on('click', function(e, t) {
			if ((t = e.target).nodeName != 'A' || (o.area && !$(t).parents(o.area).length)) {
				return;
			}
			$.ajax({
				url:t.href,
				type:'GET',
				dataType: o.dataType,
				success: o.succss
			});
			return false;
		});
	},
	/**
	 * 表格的异步请求
	 * 因为所有对数据的修改都是需要用到post方法的，有些操作是通过链接去执行，这就要求我们将链接转化为post请求，最终完成这个操作。表格的异步请求处理流程是：如果点击了链接，链接的href最后一个斜杠后面的字符串如果是以_开始的，那么这个请求就会转化为一个POST的ajax请求。
	 * @param {HTMLElement} table
	 * @param {Object} options 默认可以不传入任何值。具有如下参数：
	 * &lt;dl>
	 *  &lt;dt>href:&lt;em>string | function&lt;/em>&lt;/dt>
	 *  &lt;dd>动态获取连接的href，如果不指定，则使用链接自己的href。可以是字符串或函数。如果是函数，当前指针指向对应的元素。&lt;/dd>
	 *  &lt;dt>ok:&lt;em>function(data)&lt;/em>&lt;/dt>
	 *  &lt;dd>表单提交成功时调用的函数。&lt;/dd>
	 *  &lt;dt>error:&lt;em>function(code, desc)&lt;/em>&lt;/dt>
	 *  &lt;dd>表单提交失败是调用的函数。&lt;/dd>
	 *  &lt;dt>confirm:&lt;em>String | Function&lt;/em>&lt;/dt>
	 *  &lt;dd>确认字符串，当要执行之前会调用弹出确认框，用户确认了才继续执行。如果confirm是函数，则会将当前点击的元素作为this指针执行此confirm函数并执行，将返回的结果作为确认字符串。另外，该确认字符串可以通过元素设定confirm属性来设置。&lt;/dd>
	 *  &lt;dt>rule:&lt;em>RegExp&lt;/em>&lt;/dt>
	 *  &lt;dd>链接的url规则，必须是正则表达式，当链接符合此表达式，才会执行ajax异步请求。默认规则为：/\/_[^\/]\w+($|\?.*)/ 。&lt;/dd>
	 * &lt;/dl>
	 * @example 
如果有一块区域的链接需要进行同样的异步请求，但是这个区域不是用table来构造的，那么，可以通过如下的方法直接对其他类型的DOM节点（如div）进行异步请求处理。
jQuery.ajaxable.ajaxTable(table, options)

&lt;table id="cateList"&gt;
	&lt;thead&gt;
		&lt;tr&gt;
			&lt;th&gt;ID&lt;/th&gt;
			&lt;th&gt;名称&lt;/th&gt;
			&lt;th&gt;英文名称&lt;/th&gt;
			&lt;th&gt;是否使用&lt;/th&gt;
			&lt;th&gt;操作&lt;/th&gt;
			&lt;/tr&gt;
		&lt;/thead&gt;
	&lt;tbody&gt;
…
&lt;script&gt;
	$('#cateList').ajaxable({
		ok: function(data) {
			location.reload();
		},
		confirm: function(){
			if (this.className == 'del') {
				return '你确定要删除吗？'；
			} else {
				return '你确定要设为禁用吗？';
			}
		}
	});
 &lt;/script&gt;

	 */
	ajaxTable: function(table, options) {
		var rule = options.rule ? options.rule : '';
		if (rule.constructor !== RegExp) {
			rule = /\/_[^\/]\w+($|\/?\?.*)/;
		}
		$(table).on('click', function(e, t) {
			if ( (t= e.target).nodeName != 'A' || !rule.test(t.href)) {
				return;
			}
			ajaxPost(t, options);
			
			return false;
		});
	},
	/**
	 * ajax化一个链接
	 * 有一些单独出来的链接也是需要异步化成post请求提交的。因此单独链接也提供了ajaxable的方法，不同的是，这里不会对链接的格式进行检查。
	 * @param {HtmlElement} link
	 * @param {Object} options 默认可以不传入任何值。具有如下参数：
	 * &lt;dl>
	 *  &lt;dt>href:&lt;em>string | function&lt;/em>&lt;/dt>
	 *  &lt;dd>动态获取连接的href，如果不指定，则使用链接自己的href。可以是字符串或函数。如果是函数，当前指针指向对应的元素。&lt;/dd>
	 *  &lt;dt>ok:&lt;em>function(data)&lt;/em>&lt;/dt>
	 *  &lt;dd>表单提交成功时调用的函数。&lt;/dd>
	 *  &lt;dt>error:&lt;em>function(code, desc)&lt;/em>&lt;/dt>
	 *  &lt;dd>表单提交失败是调用的函数。&lt;/dd>
	 *  &lt;dt>confirm:&lt;em>String | Function&lt;/em>&lt;/dt>
	 *  &lt;dd>确认字符串，当要执行之前会调用弹出确认框，用户确认了才继续执行。如果confirm是函数，则会将当前点击的元素作为this指针执行此confirm函数并执行，将返回的结果作为确认字符串。另外，该确认字符串可以通过元素设定confirm属性来设置。&lt;/dd>
	 * &lt;/dl>
	 * @example 
也可以通过如下的方法直接对一个链接进行异步请求处理。
jQuery.ajaxable.ajaxLink(link, options)

&lt;a href="/unlock" id="linkPost"&gt;解除绑定&lt;/a&gt;
&lt;script&gt;
	$('#linkPost').ajaxable({
		ok: function(data) {
			location.reload();
		}
	});
 &lt;/script&gt;
	 */
	ajaxLink: function(link, options) {
		$(link).on('click', function(){
			ajaxPost(this, options);
			return false;
		});
	}
};

/**
 * @description 让元素支持一些异步请求的操作。由于async这个单词比较生僻，故使用ajax来替代。目前支持四种方式的异步请求方式。分别为：图片、表单、下拉框、表格、面板。
 * &lt;br/>
 * 这部分接口设计得比较灵活，可以通过两种方式调用：
 * &lt;ol>
 * &lt;li>直接使用jQuery的函数ajaxable，这个函数会根据元素的nodeName来进行判断该使用哪种接口完成操作。该方法只有一个参数：ajaxable(options)，里边传入相关的配置项&lt;/li>
 * &lt;li>直接使用定义到jQuery.ajaxable这个对象的具体函数来进行相关操作。该方法有两个参数：ajax[Form|Img|Select|Panel](node, options)，其中node为一个DOM节点或jQuery对象，options也是配置项，和1完全一样。&lt;/li>
 * &lt;/ol>
 * 我们需要使表单（id=formAdd）提交支持异步操作，可以分别如下使用：&lt;br/>
 * &lt;ol>
 * &lt;li>H.ui.id('formAdd').ajaxable();&lt;/li>
 * &lt;li>H.ui.ajaxable.ajaxForm(H.ui._id('formAdd'));&lt;/li>
 * &lt;/ol>
 * @constructor jQuery.fn.ajaxable
 * @param {Object} opt 选项
 * &lt;dl>
 * 	&lt;dt>confirm&lt;dt>
 * 	&lt;dd>确认信息，可以是Function、String&lt;/dd>
 * 	&lt;dt>ok&lt;dt>
 * 	&lt;dd>异步化请求成功后调用的函数&lt;/dd>
 * &lt;/dl>
 * @example
 * 详见&lt;a href="http://dxl.hapn.cc/grunt/examples/ajaxable.html" target="_blank">例子&lt;/a>&lt;br/>
 * 针对各种元素的使用方法参见&lt;a href="./hapj.ui.ajaxable.html">详细&lt;/a>
 */
$.fn.ajaxable = function(opt) {
	var options = opt || {};
	this.each(function(k, v) {
		switch(v.tagName) {
			case 'FORM':
				H.ui.ajaxable.ajaxForm(v, options);
				break;
			case 'IMG':
				H.ui.ajaxable.ajaxImg(v, options);
				break;
			case 'SELECT':
				H.ui.ajaxable.ajaxSelect(v, options);
				break;
			case 'TABLE':
				H.ui.ajaxable.ajaxTable(v, options);
				break;
			case 'A':
				H.ui.ajaxable.ajaxLink(v, options);
				break;
			default:
				H.ui.ajaxable.ajaxPanel(v, options);
				break;
		}
	});
	return this;
};

}(jQuery);</code></pre>
        </article>
    </section>




</div>

<nav>
<h2><a href="index.html">Index</a></h2><h3>Namespaces</h3><ul><li><a href="hapj.array.html">hapj.array</a></li><li><a href="hapj.browser.html">hapj.browser</a></li><li><a href="hapj.cache.html">hapj.cache</a></li><li><a href="hapj.conf.html">hapj.conf</a></li><li><a href="hapj.date.html">hapj.date</a></li><li><a href="hapj.json.html">hapj.json</a></li><li><a href="hapj.log.html">hapj.log</a></li><li><a href="hapj.object.html">hapj.object</a></li><li><a href="hapj.page.html">hapj.page</a></li><li><a href="hapj.string.html">hapj.string</a></li><li><a href="jQuery.html">jQuery</a></li><li><a href="jQuery.ajaxable.html">jQuery.ajaxable</a></li><li><a href="jQuery.fn.html">jQuery.fn</a></li><li><a href="jQuery.verifiable.html">jQuery.verifiable</a></li></ul><h3>Classes</h3><ul><li><a href="hapj.html">hapj</a></li><li><a href="hapj.ajax.html">hapj.ajax</a></li><li><a href="hapj.ui.html">hapj.ui</a></li><li><a href="hapj.ui.fn.html">hapj.ui.fn</a></li><li><a href="jQuery.fn.ajaxable.html">jQuery.fn.ajaxable</a></li><li><a href="jQuery.fn.calendar.html">jQuery.fn.calendar</a></li><li><a href="jQuery.fn.floatable.html">jQuery.fn.floatable</a></li><li><a href="jQuery.fn.lazyload.html">jQuery.fn.lazyload</a></li><li><a href="jQuery.fn.menuable.html">jQuery.fn.menuable</a></li><li><a href="jQuery.fn.selectable.html">jQuery.fn.selectable</a></li><li><a href="jQuery.fn.suggestable.html">jQuery.fn.suggestable</a></li><li><a href="jQuery.fn.switchable.html">jQuery.fn.switchable</a></li><li><a href="jQuery.fn.verifiable.html">jQuery.fn.verifiable</a></li><li><a href="jQuery.verifiable.rules.html">jQuery.verifiable.rules</a></li></ul>
</nav>

<br clear="both">

<footer>
Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Thu Sep 25 2014 20:22:51 GMT+0800 (CST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
